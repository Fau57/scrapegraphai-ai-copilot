[
    {
        "prompt": "In scrapegraph ai, what is the purpose of the BurrBridge class?",
        "answer": "The `BurrBridge` class in scrapegraph ai is responsible for integrating Burr into ScrapeGraphAI graphs. It converts a base graph to a Burr application and executes it with the given initial state."
    },
    {
        "prompt": "In scrapegraph ai, what are the attributes of the BurrBridge class?",
        "answer": "The attributes of the `BurrBridge` class in scrapegraph ai are `base_graph` (the base graph to convert to a Burr application), `burr_config` (configuration parameters for the Burr application), `tracker` (the tracking client for the Burr application), `app_instance_id` (the instance ID for the Burr application), `burr_inputs` (the inputs for the Burr application), and `burr_app` (the Burr application instance)."
    },
    {
        "prompt": "In scrapegraph ai, what are the methods of the BurrBridge class?",
        "answer": "The methods of the `BurrBridge` class in scrapegraph ai are `__init__` (initializes the BurrBridge object), `_initialize_burr_app` (initializes a Burr application from the base graph), `_create_actions` (creates Burr actions from the base graph nodes), `_create_transitions` (creates Burr transitions from the base graph edges), `_convert_state_from_burr` (converts a Burr state to a dictionary state), and `execute` (executes the Burr application with the given initial state)."
    },
    {
        "prompt": "In scrapegraph ai, what is the purpose of the BurrNodeBridge class?",
        "answer": "The `BurrNodeBridge` class in scrapegraph ai is a bridge class to convert a base graph node to a Burr action. This allows for dynamic declaration of inputs/outputs without relying on function-parsing."
    },
    {
        "prompt": "In scrapegraph ai, what are the attributes of the BurrNodeBridge class?",
        "answer": "The attribute of the `BurrNodeBridge` class in scrapegraph ai is `node` (the base graph node to convert to a Burr action)."
    },
    {
        "prompt": "In scrapegraph ai, what are the methods of the BurrNodeBridge class?",
        "answer": "The methods of the `BurrNodeBridge` class in scrapegraph ai are `__init__` (initializes the BurrNodeBridge object), `run` (executes the base graph node with the given inputs), `update` (updates the Burr state with the result of the base graph node), `get_source` (returns the source code of the base graph node class), and the properties `reads` (the inputs of the base graph node) and `writes` (the output of the base graph node)."
    },
    {
        "prompt": "Show me the implementation of the BurrBridge and BurrNodeBridge classes in scrapegraph ai.",
        "answer": "Sure, hereâ€™s the code for the `BurrBridge` and `BurrNodeBridge` classes:\n\n```python\n\"\"\"\nBridge class to integrate Burr into ScrapeGraphAI graphs\n[Burr](https://github.com/DAGWorks-Inc/burr)\n\"\"\"\n\nimport re\nfrom typing import Any, Dict, List, Tuple\nimport inspect\n\ntry:\n    import burr\nexcept ImportError:\n    raise ImportError(\"burr package is not installed. Please install it with 'pip install scrapegraphai[burr]'\")\n\nfrom burr import tracking\nfrom burr.core import Application, ApplicationBuilder, State, Action, default\nfrom burr.lifecycle import PostRunStepHook, PreRunStepHook\n\n\nclass PrintLnHook(PostRunStepHook, PreRunStepHook):\n    \"\"\"\n    Hook to print the action name before and after it is executed.\n    \"\"\"\n\n    def pre_run_step(self, *, state: \"State\", action: \"Action\", **future_kwargs: Any):\n        print(f\"Starting action: {action.name}\")\n\n    def post_run_step(self, *, state: \"State\", action: \"Action\", **future_kwargs: Any):\n        print(f\"Finishing action: {action.name}\")\n\n\nclass BurrNodeBridge(Action):\n    \"\"\"Bridge class to convert a base graph node to a Burr action.\n    This is nice because we can dynamically declare the inputs/outputs (and not rely on function-parsing).\n    \"\"\"\n\n    def __init__(self, node):\n        \"\"\"Instantiates a BurrNodeBridge object.\n        \"\"\"\n        super(BurrNodeBridge, self).__init__()\n        self.node = node\n\n    @property\n    def reads(self) -> list[str]:\n        return parse_boolean_expression(self.node.input)\n\n    def run(self, state: State, **run_kwargs) -> dict:\n        node_inputs = {key: state[key] for key in self.reads if key in state}\n        result_state = self.node.execute(node_inputs, **run_kwargs)\n        return result_state\n\n    @property\n    def writes(self) -> list[str]:\n        return self.node.output\n\n    def update(self, result: dict, state: State) -> State:\n        return state.update(**result)\n    \n    def get_source(self) -> str:\n        return inspect.getsource(self.node.__class__)\n\n\ndef parse_boolean_expression(expression: str) -> List[str]:\n    \"\"\"\n    Parse a boolean expression to extract the keys used in the expression, without boolean operators.\n\n    Args:\n        expression (str): The boolean expression to parse.\n\n    Returns:\n        list: A list of unique keys used in the expression.\n    \"\"\"\n\n    # Use regular expression to extract all unique keys\n    keys = re.findall(r'\\w+', expression)\n    return list(set(keys))  # Remove duplicates\n\n\nclass BurrBridge:\n    \"\"\"\n    Bridge class to integrate Burr into ScrapeGraphAI graphs.\n\n    Args:\n        base_graph (BaseGraph): The base graph to convert to a Burr application.\n        burr_config (dict): Configuration parameters for the Burr application.\n\n    Attributes:\n        base_graph (BaseGraph): The base graph to convert to a Burr application.\n        burr_config (dict): Configuration parameters for the Burr application.\n        tracker (LocalTrackingClient): The tracking client for the Burr application.\n        app_instance_id (str): The instance ID for the Burr application.\n        burr_inputs (dict): The inputs for the Burr application.\n        burr_app (Application): The Burr application instance.\n\n    Example:\n        >>> burr_bridge = BurrBridge(base_graph, burr_config)\n        >>> result = burr_bridge.execute(initial_state={\"input_key\": \"input_value\"})\n    \"\"\"\n\n    def __init__(self, base_graph, burr_config):\n        self.base_graph = base_graph\n        self.burr_config = burr_config\n        self.project_name = burr_config.get(\"project_name\", \"default-project\")\n        self.tracker = tracking.LocalTrackingClient(project=self.project_name)\n        self.app_instance_id = burr_config.get(\"app_instance_id\", \"default-instance\")\n        self.burr_inputs = burr_config.get(\"inputs\", {})\n        self.burr_app = None\n\n    def _initialize_burr_app(self, initial_state: Dict[str, Any] = {}) -> Application:\n        \"\"\"\n        Initialize a Burr application from the base graph.\n\n        Args:\n            initial_state (dict): The initial state of the Burr application.\n\n        Returns:\n            Application: The Burr application instance.\n        \"\"\"\n\n        actions = self._create_actions()\n        transitions = self._create_transitions()\n        hooks = [PrintLnHook()]\n        burr_state = State(initial_state)\n\n        app = (\n            ApplicationBuilder()\n            .with_actions(**actions)\n            .with_transitions(*transitions)\n            .with_entrypoint(self.base_graph.entry_point)\n            .with_state(**burr_state)\n            .with_identifiers(app_id=self.app_instance_id)\n            .with_tracker(self.tracker)\n            .with_hooks(*hooks)\n            .build()\n        )\n        return app\n\n    def _create_actions(self) -> Dict[str, Any]:\n        \"\"\"\n        Create Burr actions from the base graph nodes.\n\n        Returns:\n            dict: A dictionary of Burr actions with the node name as keys and the action functions as values.\n        \"\"\"\n\n        actions = {}\n        for node in self.base_graph.nodes:\n            action_func = BurrNodeBridge(node)\n            actions[node.node_name] = action_func\n        return actions\n\n    def _create_transitions(self) -> List[Tuple[str, str, Any]]:\n        \"\"\"\n        Create Burr transitions from the base graph edges.\n\n        Returns:\n            list: A list of tuples representing the transitions between Burr actions.\n        \"\"\"\n\n        transitions = []\n        for from_node, to_node in self.base_graph.edges.items():\n            transitions.append((from_node, to_node, default))\n        return transitions\n\n    def _convert_state_from_burr(self, burr_state: State) -> Dict[str, Any]:\n        \"\"\"\n        Convert a Burr state to a dictionary state.\n\n        Args:\n            burr_state (State): The Burr state to convert.\n\n        Returns:\n            dict: The dictionary state instance.\n        \"\"\"\n\n        state = {}\n        for key in burr_state.__dict__.keys():\n            state[key] = getattr(burr_state, key)\n        return state\n\n    def execute(self, initial_state: Dict[str, Any] = {}) -> Dict[str, Any]:\n        \"\"\"\n        Execute the Burr application with the given initial state.\n\n        Args:\n            initial_state (dict): The initial state to pass to the Burr application.\n\n        Returns:\n            dict: The final state of the Burr application.\n        \"\"\"\n\n        self.burr_app = self._initialize_burr_app(initial_state)\n\n        # TODO: to fix final nodes detection\n        final_nodes = [self.burr_app.graph.actions[-1].name]\n\n        last_action, result, final_state = self.burr_app.run(\n            halt_after=final_nodes,\n            inputs=self.burr_inputs\n        )\n\n        return self._convert_state_from_burr(final_state)\n```"
    }
]
  